\chapter{ワークB 脈拍測定プログラム開発}

\section{はじめに}
% 本ワークの目的
本ワークでは，心拍測定のためのプログラムを開発することを目的に実習を行なった．
本実習では，マイコンとしてArduinoを利用し，脈波信号としてAtomLiteを利用した．
また，実行結果をcsvファイルとグラフにすることで，脈拍計測システムの機能と性能の検証を行った．
\section{ワークB-1}
% ワークB-1の目的と実施内容を記載せよ
\subsection{目的と実施内容}
ワークB-1では，	AtomLiteからの4種類の信号の中から脈波信号を出しているものを特定することが目的である．
方法として，信号をArduinoを用いてAD変換し，その値で波形のグラフを描画する．
波形の形を一般的な脈波波形と比較することにより，AtomLiteから出ている脈波を特定する．
\subsection{脈波信号の検討}
% 出力した各信号波形の図を参照し，特徴を説明した上で，どの信号波形が脈波なのか結論を述べること
% 根拠について参考にした文献がある場合は，参考文献に追加した上で，説明を記述する際に引用せよ
AtomLiteには4種類の信号が記録されている．この信号はAtomeLiteに付属しているLEDの色が一つずつ対応している．
色は，赤，青，緑，紫がある．この4つの中の一つに脈波が記録されているため，それぞれの色の波形をグラフにすることで，脈波がどの色かを判別する．
判別方法として，人間の一般的な脈拍を利用する．人間の一般的な脈拍は安静時に1分あたり60回から100回とされている\cite{public_pulse}．
また，波形は1周期の間に複数の山が出現することが知られている\cite{public_pulse_pattern}．
そのため，ワークB-1では5秒間記録を取り，グラフに表す．グラフに5回から8回程度のピークが見ることができると考えられる．よって，これを利用し，判別を行う．
赤の波形は図\ref{redpulse}に表す．この図から，ピークが5回あることがわかる．また，1周期も複数の小さい山と大きい1つの山で構成されている．
そのため，この波形は人間の脈波波形であると十分にいえると考えられる．
\begin{figure}[H]
    \centering
        \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b1/b1_026_red.png}
        \caption{赤色の波形}
    \label{redpulse}
\end{figure}
青の波形は図\ref{bluepulse}に表す．この図から，ピークは7回であることがわかる．しかし，1周期の間に複数の山が見られない．
そのため，人間の脈波波形であるとは言えないと考えられる．
\begin{figure}[H]
    \centering
        \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b1/b1_026_blue.png}
        \caption{青色の波形}
    \label{bluepulse}
\end{figure}
緑の波形は図\ref{greenpulse}に表す．この図から，ピークが数多く見られ，人間の脈拍にしては多いことがわかる．そのため，人間の脈波波形ではないと考えられる．

\begin{figure}[H]
    \centering
        \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b1/b1_026_green.png}
        \caption{緑色の波形}
    \label{greenpulse}
\end{figure}
紫の波形は図\ref{perplepulse}に表す．この図から，ピークが数多く見られ，人間の脈拍にしては多いことがわかる．そのため，人間の脈波波形ではないと考えられる．
\begin{figure}[H]
    \centering
        \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b1/b1_026_perple.png}
        \caption{紫色の波形}
    \label{perplepulse}
\end{figure}
これら全ての波形のグラフから，赤の波形が人間の脈波であると結論づける．
\subsection{実装内容}
% ファイルごとにプログラムを記載し，変更・追加した処理について説明すること（ipynbファイルは必要ない）
% 変更しなかったファイルについては，変更していないことを説明すること
ワークB-1では，b1\_signal\_cheak.inoを実装した．プログラム内容は図\ref{b1_signal_check}にある通りである．

3行目では，シリアルモニターにtime，valueと1行でプログラム起動時にのみ表示するようにしている．
10から17行目のコードはif文を用いて，11から16行目のプログラムが5秒間のみ実行される．
11行目では，経過時間であるミリ秒を秒に変換している．12から14行目では，秒数とアナログ値が1行で表示されるようになっている．
\begin{figure}[H]
    \begin{lstlisting}
void setup() {
  Serial.begin(9600); 
  Serial.println("time,value");
}

void loop() {
  uint16_t v = analogRead(A0);  // アナログ入力を読み取る
  uint32_t t = millis();        // 起動からの時間を計測

if(t<5000){                     
  float t_second=t/1000.0;
  Serial.print(t_second);            // 計測した時間をシリアル出力
  Serial.print(",");
  Serial.println(v);            // 読み取った値をシリアル出力

  delay(20);                    // 次のループまで 20 ミリ秒待機
}
}
    \end{lstlisting}
    \caption{b1\_signal\_check.ino}
    \label{b1_signal_check}
\end{figure}

\section{ワークB-2}
% ワークB-2の目的と実施内容を記載せよ
\subsection{目的と実施内容}
ワークB-2では，B-1にて特定した脈波の1周期の最大値を検知し，マークをつけることが目的である．

方法として，Arduinoで，適当な閾値を設定することにより，Arduinoが検知したピークを波形に印をつける．
閾値はTOP\_THRESHOLDとDOWN\_THRESHOLDが用意されている．TOP\_THRESHOLDは，ピーク検出プログラムを実行させる値であり，設定値を上回ったときにのみ実行される．
DOWN\_THRESHOLDは，ピークが存在したことを決定する値である．読み取ったアナログ値が前回値を下回った回数がDOWN\_THRESHOLDに達した時に記録していた最大値をピークとする．
この作業を複数回行うことにより，印がすべてのピークに適切に付けられる閾値を決定する．
\subsection{閾値の検討}
% TOP_THRESHOLDとDOWN_THRESHOLDの組み合わせに応じたグラフを基に比較を行い，最終的な閾値がなぜ最適であるかを考察すること
閾値はワークB-2の検討の結果，TOP\_THRESHOLDが400，DOWN\_THRESHOLDが2に設定することが適切であると判断した．
この検討手段について説明する．

まず初めに，閾値はDOWN\_THRESHOLDを4で固定し，TOP\_THRESHOLDの適切な値を見つける作業を行った．
図\ref{t_300_d_4}ではTOP\_THRESHOLDを300に設定したものである．
この閾値では，小さい山でもピークと判断され，印が付けられていることがわかる．そのため，TOP\_THRESHOLDが300では足りないことがわかる．
また，DOWN\_THRESHOLDは全てのピークに付いているため，TOP\_THRESHOLDが300の時は適切であることがわかる．
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b2/b2_026_top300_down4.png}
    \caption{TOP\_THRESHOLDが300，DOWN\_THRESHOLDが4の時の波形}
    \label{t_300_d_4}
\end{figure}
図\ref{t_350_d_4}ではTOP\_THRESHOLDを350に設定したものである．
この閾値では，小さい山にもピークと判定され，印が付けられていることがわかる．そのため，TOP\_THRESHOLDが350では足りないことがわかる．
また，DOWN\_THRESHOLDは全てのピークに付いているため，TOP\_THRESHOLDが350の時は適切であることがわかる．
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b2/b2_026_top350_down4.png}
    \caption{TOP\_THRESHOLDが350，DOWN\_THRESHOLDが4の時の波形}
    \label{t_350_d_4}
\end{figure}
図\ref{t_400_d_4}ではTOP\_THRESHOLDを400に設定したものである．
この閾値では，小さい山にピークと判定され，印が付けられていないことがわかる．そのため，TOP\_THRESHOLDは400が適切な値だとわかる．
しかし，DOWN\_THRESHOLDは全てのピークに付いていないため，TOP\_THRESHOLDが400の時は値が大きいことがわかる．
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b2/b2_026_top400_down4.png}
    \caption{TOP\_THRESHOLDが400，DOWN\_THRESHOLDが4の時の波形}
    \label{t_400_d_4}
\end{figure}
TOP\_THRESHOLDの適切な値が400と判明したため，DOWN\_THRESHOLDの適切な値を設定する．

図\ref{t_400_d_3}ではDOWN\_THRESHOLDを3に設定したものである．
この閾値では，全てのピークに対してマークが付けられているため，適切のように見える．
しかし，2秒付近の山には3回目の下降がTOP\_THRESHOLDの設定値付近であるため，ブレにより検出できない可能性がある．
そのため，DOWN\_THRESHOLDの値が3は安定性に欠けるため適切とは言えない．
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b2/b2_026_top400_down3.png}
    \caption{TOP\_THRESHOLDが400，DOWN\_THRESHOLDが3の時の波形}
    \label{t_400_d_3}
\end{figure}
図\ref{t_400_d_2}ではDOWN\_THRESHOLDを2に設定したものである．
この閾値では，全てのピークに対してマークが付けられているおり，TOP\_THRESHOLDの設定値とも余裕があるため，DOWN\_THRESHOLDの設定値は2が適切である．
\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b2/b2_026_top400_down2.png}
    \caption{TOP\_THRESHOLDが400，DOWN\_THRESHOLDが2の時の波形}
    \label{t_400_d_2}
\end{figure}
これらの複数回の検討により，閾値は，TOP\_THRESHOLDが400，DOWN\_THRESHOLDが2に設定することが適切であることが確認できた．
\subsection{実装内容}
% ファイルごとにプログラムを記載し，変更・追加した処理について説明すること（ipynbファイルは必要ない）
% 変更しなかったファイルについては，変更していないことを説明すること
ワークB-2では，b2\_peak\_detection.inoとmyPulse.hとmyPulse.cppを実装した．
図\ref{b2_peak_detection}はb2\_peak\_detection.inoを示している．このプログラムはtop関数を5秒間動作させるものである．
5行目では，シリアルモニターにtime，value，peakをプログラム起動時に一度だけ出力している．
9行目では，起動からの時間を記録している．10から12行目では，5秒間top関数を呼び出し続ける．
\begin{figure}[H]
    \begin{lstlisting}
#include "myPulse.h"

void setup() {
  Serial.begin(115200); 
  Serial.println("time,value,peak");
}

void loop() {
  uint32_t t = millis();
  if (t < 5000) {
    top();
  }
}
    \end{lstlisting}
    \caption{b2\_peak\_detection.ino}
    \label{b2_peak_detection}
\end{figure}

図\ref{b2_myPulse.h}はmyPulse.hを示している．このプログラムには手を加えていないため，説明は省略する．
\begin{figure}[H]
        \begin{lstlisting}
#ifndef MyPulse_h
#define MyPulse_h

#include <Arduino.h>

uint16_t top();

#endif
    \end{lstlisting}
     \caption{myPulse.h}
    \label{b2_myPulse.h}
\end{figure}

図\ref{b2_myPulse.cpp}と図\ref{b2_myPulse.cpp_2}はmyPulse.cppを示している．
17行目では，配列の要素数を上限300で固定している．これは，20msに一回記録をとるため，6秒間記録を保持できるようになっている．
18から20行目では，配列を用いて，Vboxはアナログ値，Tboxは時間，Pboxはピークの判定値を記録できるようにしている．
21行目では，配列のどの場所に入れるかを保存する変数である．
26から31行目では，配列の保存容量を超えない限りアナログ値，時間，ピーク判定値0を記録する．
44から47行目では，配列の中身を1から確認し，検出したアナログ値の最大値と同じ場所をピーク判定値を0から1に変更している．
48から52行目では，時間，アナログ値，ピーク判定値を1行にしてシリアルモニターに出力している．
\begin{figure}[H]
    \begin{lstlisting}
#include "myPulse.h"

# define PIN_IN A0        
# define DELAY_TIME 20  

# define TOP_THRESHOLD 0  
# define DOWN_THRESHOLD 0 
# define UP_THRESHOLD 1   

uint16_t top(){
  uint32_t time = 0;              // 信号の受信時間の保存用
  uint16_t maximum = 0;           // 最大値の保存用
  uint16_t value = 0;             // 読み込んだ信号の保存用    
  uint8_t up_count = 0;           // 上昇回数の保存用
  uint8_t down_count = 0;         // 下降回数の保存用
  uint8_t timeout = 255;         // タイムアウトまでのカウント
  const int Baffer_size=300;  
  uint16_t Vbox[Baffer_size];   
  uint32_t Tbox[Baffer_size];   
  uint8_t Pbox[Baffer_size];   
  int baffer_index=0;        

  while(timeout--){    
    value = analogRead(PIN_IN);   // アナログ入力で値を読み取る
    time = millis();              // 起動からの時間を計測
    if(baffer_index<Baffer_size){   
        Vbox[baffer_index]=value;
        Tbox[baffer_index]=time;
        Pbox[baffer_index]=0;
        baffer_index++;
      }

    if(value >= TOP_THRESHOLD){   // 読み込んだ値が山の閾値以上である場合のみピーク検出の処理を行う
      if(value > maximum){        
        maximum = value;        
        up_count++;              
        down_count = 0;        
      }
      else{
        down_count++;
      }
    }    

    \end{lstlisting}
     \caption{myPulse.cpp}
    \label{b2_myPulse.cpp}
\end{figure}

\newpage

\begin{figure}[H]
    \begin{lstlisting}[firstnumber=43]
    if(up_count>UP_THRESHOLD && down_count>DOWN_THRESHOLD){   
      for(int i=0;i<baffer_index;i++){
        if(Vbox[i]==maximum){
          Pbox[i]=1;
        }
    Serial.print(Tbox[i]/1000.0, 2); // 時間を秒に変換して小数点二桁までシリアル出力
    Serial.print(",");
    Serial.print(Vbox[i]);          // 読み込んだ値をシリアル出力
    Serial.print(",");
    Serial.println(Pbox[i]);
    }   
      return maximum;
  }
    delay(DELAY_TIME);
   
  }
  return 0; 
}
    \end{lstlisting}
    \caption{myPulse.cpp}
    \label{b2_myPulse.cpp_2}
\end{figure}

\newpage

\section{ワークB-3}
% ワークB-3の目的と実施内容を記載せよ
\subsection{目的と実施内容}
ワークB-3では，心拍数の算出を行うことが目的である．
方法として，ワークB-2にてピークの判定が可能となった．そのため，ピークからピークまでの時間を利用して心拍数の計算を行う．
\subsection{測定結果の考察}
% 出力したグラフに加えて，測定結果から基本的な統計値（最大，最小，平均，中央値，標準偏差）を算出し表にまとめ，それぞれ参照しながら説明すること
% 統計値は表計算ソフトを使って求めて良いが，表計算ソフトのスクリーンショットを表示するのではなく，latexのtableを利用して表示すること
AtomLiteからの信号を利用し，心拍数を算出した．その統計値は表\ref{mypalse_deta}である．また，グラフは図\ref{mypalse_time}である．
表\ref{mypalse_deta}には，最大値，最小値，平均値，中央値，標準偏差がまとめられている．人間の心拍数は，60から100回が標準値であることが知られている\cite{public_pulse}．
今回のデータでは心拍数が60から69の間に収まっている．また，標準偏差が小さいため，心拍の振れ幅も小さく，安定性が高いと言える．そのため，今回のデータは，人間の安静時の心拍数の記録として妥当である．

\begin{figure}[H]
    \centering
    \includegraphics[width=0.95\textwidth,clip]{fig_work_B/b3/b3_026_pulse.png}
    \caption{計測時間と心拍数}
    \label{mypalse_time}
\end{figure}

\begin{table}[H]
  \centering
  \caption{測定心拍数の統計値}
  \begin{tabular}{|c|c|}
    \hline
    統計&値\\ \hline
    最大値&69.00\\ \hline
    最小値&60.00\\ \hline
    平均値&64.36\\ \hline
    中央値&65.00\\ \hline
    標準偏差&2.79\\ \hline
  \end{tabular}
  \label{mypalse_deta}
\end{table}

\subsection{実装内容}
% ファイルごとにプログラムを記載し，変更・追加した処理について説明すること（ipynbファイルは必要ない）
% 変更しなかったファイルについては，変更していないことを説明すること
ワークB-3では，3つのプログラムを実装した．図\ref{b3_pulse_measurement.ino}は，b3\_pulse\_measurement.inoの中身である．
このプログラムでは，5行目に，time，pulseを1行でシリアルモニターに表示している．
9行目で，起動からの時間を計測し，10から16行目のプログラムが1分間動作するように制御されている．
11行目では，rate関数から心拍数が返り値として出力されている．
12行目でミリ秒から秒に変換し，13から15行目で，時間と心拍数を1行でシリアルモニターに出力している．
\begin{figure}[H]
    \begin{lstlisting}
#include "myPulse.h"

void setup() {
  Serial.begin(115200);  //シリアル通信の開始
  Serial.println("time,pulse");
}

void loop() {
  uint32_t time=millis();
  if(time<60000){
    uint8_t pulse=rate();       
    float second=time/1000.0;
    Serial.print(second);
    Serial.print(",");
    Serial.println(pulse);
  } 
}
    \end{lstlisting}
     \caption{b3\_pulse\_measurement.ino}
    \label{b3_pulse_measurement.ino}
\end{figure}
図\ref{b3_myPulse.h}は，myPulse.hの中身である．これは配布されたものから変更を加えていないため，説明は省略する．
\begin{figure}[H]
    \begin{lstlisting}
#ifndef MyPulse_h
#define MyPulse_h

#include <Arduino.h>

uint16_t top();
uint8_t rate();

#endif
    \end{lstlisting}
    \caption{myPulse.h}
    \label{b3_myPulse.h}
\end{figure}
図\ref{b3_myPulse.cpp}と図\ref{b3_myPulse.cpp_rate}は，myPulse.cppの中身である．

図\ref{b3_myPulse.cpp}は主にtop関数が実装されている．6，7行目では，ワークB-2で決定した閾値に設定が変更されている．
32行目では返り値として時間を返すようにされている．

図\ref{b3_myPulse.cpp_rate}はrate関数が実装されている．39行目では，top関数の返り値を保存している．
40から42行目では，時間を保存する変数が定義されている．43行目は心拍数を保存する変数が定義されている．
45行目から53行目はtop関数から値が返ってきた時に動作する．46行目では，firstpeakに1回目のピークを確認できた時間を保存する．
47行目では，top関数から2回目のピークの時間である返り値がsecondpeakに保存される．
48行目から52行目では，secondpeakに値が代入された時に動作し，周期を計算し，心拍数を計算し，その値を返すようになっている．
\begin{figure}[H]
    \begin{lstlisting}
#include "myPulse.h"

# define PIN_IN A0        
# define DELAY_TIME 20    

# define TOP_THRESHOLD 400 
# define DOWN_THRESHOLD 2 
# define UP_THRESHOLD 1   

uint16_t top(){
  uint16_t maximum = 0;           // 最大値の保存用
  uint16_t value = 0;             // 読み込んだ信号の保存用    
  uint8_t up_count = 0;           // 上昇回数の保存用
  uint8_t down_count = 0;         // 下降回数の保存用
  uint8_t timeout = 255;         // タイムアウトまでのカウント
  uint32_t time=millis();
  while(timeout--){    
    value = analogRead(PIN_IN);   // アナログ入力で値を読み取る

    if(value >= TOP_THRESHOLD){   // 読み込んだ値が山の閾値以上である場合のみピーク検出の処理を行う
      if(value > maximum){      
        maximum = value;       
        up_count++;             
        down_count = 0;      
      }
      else{
        down_count++;           
      }
    }

      if(up_count>UP_THRESHOLD && down_count>DOWN_THRESHOLD) {     
      return time;
      }
    delay(DELAY_TIME);
  }
  return 0;  
}
    \end{lstlisting}
    \caption{myPulse.cppのtop関数}
    \label{b3_myPulse.cpp}
\end{figure}

\begin{figure}[H]
  \begin{lstlisting}[firstnumber=38]
uint8_t rate(){  
  uint16_t peaktime=top();
  uint16_t firstpeak;
  uint16_t secondpeak;
  uint16_t interval;
  uint8_t bpm;

  if(peaktime>0){
      firstpeak=peaktime;
      secondpeak=top();
      if(secondpeak!=0){
        interval=secondpeak-firstpeak;
        bpm=60000/interval;
        return bpm;
      }
    }
    return 0;
}
    \end{lstlisting}
    \caption{myPulse.cppのrate関数}
    \label{b3_myPulse.cpp_rate}
\end{figure}